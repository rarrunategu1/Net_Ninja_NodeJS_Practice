WHAT IS NODE.JS
a javascript runtime built on Chrome's V8 Javascript engine.
(Allows us to run javascripton a computer/serveer)
It's event driven and non-blocking. -very fast since it's nonblocking and since it uses V8 engine   
(Read, delete and update files; easily communicate with a database)
Its package ecosystem, npm, is the largesst ecosystem of open source libraries in the world.
Great for real time services - Chatrooms

Inner workings
-v8 engine, modules, event emiiter, fs

Creating a web server
-routing, express, templating

HOW TO INSTALL NODE JS
Go to nodejs.org and download one
Note that when downloading pick the one that says LTS (Long Term Support) - because it's the most stable

in the command line write node -v to find out what version you have

*if you're in the folder where your app is, then you can run it on the command line by just using node app.  You don't need to do node app.js

V8 ENGINE
What is a javascript engine?
    -computers don't understand javascript and so the engine converts it into machine code so that it is understood.
    -this machine code is not good for programming because it's messy and hard to understand.  It's how computers talk.
    
    Node JS is written in C++ because it uses the v8 engine (embedded in it) which is also written in C++ but it allows us to write javascript which can run on a computer or server
    
THE GLOBAL OBJECT
When writing javascript in browser, the global object is the window object and we can access properties and methods like alert, settimeout etc.
When writing it in node, it's no longer a window object.  It's a global object that still gives us access to some methods we can use in node js
    
    
on node we can

console.log

setTimeout -
setTimeout(function(){
    console.log('3 seconds have passed');
}, 3000);

setInterval -
var time = 0;
setInterval(function() {
    time +=2;
 console.log(time + '3 seconds have passed');
}, 2000); //this will give you something like this when you run it:
23 seconds have passed
43 seconds have passed
63 seconds have passed
83 seconds have passed
103 seconds have passed
123 seconds have passed
143 seconds have passed
163 seconds have passed
183 seconds have passed
203 seconds have passed
223 seconds have passed
ctrl C will stop it in the terminal

An example of using a timer is:
var time = 0;

var timer = setInterval(function() {
    time +=2;
 console.log(time + '3 seconds have passed');
 if (time > 5){  //after 5 seconds it'll stop running the function
     clearInterval(timer);
 }
}, 2000); 

Enter the following on the app.js file:

console.log(__dirname); //when you run the code it will return the directory youre in

console.log(__filename);  //this will return the file name youre working on.

Look up in google -> node.js 'the version you have' documentation  - to find more information on global objects in node

FUNCTION EXPRESSIONS

//normal function statement
function sayHi() {
    console.log('hi');
}

sayHi();

//function expression
var sayBye = function(){
    console.log('bye');
};

sayBye();

//a function within a function
function callFunction(fun){ //this is a function that takes a function as a parameter
    fun(); //this calls that function
}

//function expression
var sayBye = function(){
    console.log('bye');
};
callFunction(sayBye); //when you call this it uses the sayBye function in the callFunction so when you run it, it returns bye


MODULES AND REQUIRE()

You would usually break up a node js file into modules, so you
can create a module that counts something and call upon that module
when you need to count something.

A module is just another javascript file

example of count module in count.js file
var counter = function(arr){
    return 'There are ' + arr.length + ' elements in this array';
    
};

console.log(counter(['shaun', 'crystal', 'ryu']));

if you want to run the count file in the app. js do the following:

in app.js
var counter = require('./count');

console.log(counter(['shaun', 'crystal', 'ryu']));

In count.js //take note that the file name was changed to stuff.js
var counter = function(arr){
    return 'There are ' + arr.length + ' elements in this array';
    
};

module.exports = counter; //this makes the counter function available outside of this module so I can require it in my app.js


MODULE PATTERNS

What if we want to call multiple modules:

In app.js
var stuff = require('./stuff');

console.log(stuff.counter(['shaun', 'crystal', 'ryu']));
console.log(stuff.adder(5,6));
console.log(stuff.adder(stuff.pi, 5));

in stuff.js
var counter = function(arr){
    return 'There are ' + arr.length + ' elements in this array';
    
};

var adder = function (a,b){
    return `The sum of the 2 number is ${a+b}`;  //template string has backticks and it allows us to embed variables or expressions without concatentation
    };
    
var pi = 3.142;

module.exports.counter = counter; //this makes the counter function available outside of this module so I can require it in my app.js
module.exports.adder = adder;
module.exports.pi = pi;

You can save some code space by doing the following instead on the stuff.js
module.exports.counter = function(arr){
    return 'There are ' + arr.length + ' elements in this array';
    
};

module.exports.adder = function (a,b){
    return `The sum of the 2 number is ${a+b}`;  //template string has backticks and it allows us to embed variables or expressions without concatentation
    };
    
module.exports.pi = 3.142;


Or we could do the stuff.js file like this
var counter = function(arr){
    return 'There are ' + arr.length + ' elements in this array';
    
};

var adder = function (a,b){
    return `The sum of the 2 number is ${a+b}`;  //template string has backticks and it allows us to embed variables or expressions without concatentation
    };
    
var pi = 3.142;

module.exports = {
counter: counter,
adder: adder,
pi: pi
});


THE EVENT MODULE

Node JS comes with built in modules and we can require them just like custom modules
An example is the event module

see the example below in a app.js file
var events = require('events');

var myEmitter = new events.EventEmitter(); //now this will have an eventEmitter object stored here

myEmitter.on('someEvent', function(mssg){
    console.log(mssg);
});

myEmitter.emit('someEvent', 'the event was emitted'); //We're manually emitting the 'some event' and passing the parameter mssg



There is also a utilities module called util which allows us to inherit certain things from object built into node js or other objects


var events = require('events');
var util = require('util');

var Person = function(name){ //person is an object constructor
    this.name = name;
};

util.inherits(Person, events.EventEmitter) //this allows us to make the Person variable inherit the eventemitter so that we can attach custom events to certain people.

var james = new Person('james');
var mary = new Person('mary');
var rose = new Person('rose');

var people = [james, mary, rose];

people.forEach(function(person){
    person.on('speak', function(mssg){
       console.log(person.name + ' said: ' + mssg); 
    });
});

james.emit('speak', 'hey dudes');



READING AND WRITING FILES
using node core module fs

How to read a file:
in app.js
var fs = require('fs');  //common practice is to set the variable name to the module name

//method that will go out and read readme.txt file below:
var readme = fs.readFileSync('readme.txt', 'utf8'); //this is blocking code that will not allow anything else till it's complete, but there is an asynchrynous versio that is nonblocking
//utf8 is an encodent that translates the binary data its reading from the readme.txt file into something I can understand
console.log(readme);

//will return contents of readme.txt

How to write a file
var fs = require('fs');  //common practice is to set the variable name to the module name

//method that will go out and read readme.txt file below:
var readme = fs.readFileSync('readme.txt', 'utf8'); //this is blocking code that will not allow anything else till it's complete, but there is an asynchrynous versio that is nonblocking
//utf8 is an encodent that translates the binary data its reading from the readme.txt file into something I can understand
fs.writeFileSync('writeMe.txt', readme); //created a new file writeMe.txt from the contents of the readme variable


This is asynchronous version of the code that is nonblocking:
var fs = require('fs');  //common practice is to set the variable name to the module name

fs.readFile('readme.txt', 'utf8', function(err, data){
   fs.writeFile('writeMe.txt', data);
}); //since we removed the Sync it's now asynchronous and we need a call back function to fire when the process is complete
//it's also nonblocking and won't stop the rest of the code beneath, it just continues and will fire the function when it's ready



CREATE AND REMOVE DIRECTORIES

how to delete a file
var fs = require('fs');  

fs.unlink('writeMe.txt'); //using the unlink method will delete a file


how to create a directory
-you can do this sync or async
var fs = require('fs');  

This is Sync(blocking)
fs.mkdirSync('stuff'); //this makes a directory 'stuff' Synchronously(blocking)
//to delete:
fs.rmdirSync('stuff');

This is async(non blocking)
var fs = require('fs');  

fs.mkdir('stuff', function(){ //this makes a directory 'stuff' async(nonblocking)
    fs.readFile('readme.txt', 'utf8', function(err, data){ //will read readme.txt and convert to readable txt into data
        fs.writeFile('./stuff/writeMe.txt', data); //will write a new file inside the new directory stuff with the contents of readme.txt
        
    });
}); 


CLIENTS AND SERVERS

How does the server communicate with the browser?

A socket is a channel where information can be sent.

ftp is file transfer protocol
http is used for websites

ftp or http is sent from the server to the client via a protocol called TCP, which splits up the data into smaller sections and transfers the along the socket.  Those sections are called packets

Ports
a program running on a computer can listen to requests sent to a particular port number
if node js is listening to a certain port number on the IP it will respond, but if the request is not there, it won't

CREATING A SERVER

//on the response we can send the data with response headers and the request with request headers

Response Headers
-Content-Type so that browser knows what to expect - ex. html, json - so that it knows how to deal with it
-status  - like 200 if ok or 404 if there's an error


STREAMS AND BUFFERS

Buffer is a temp spot for a chunk of data that being transferred from one place to another

Stream is just a stream of data that flows from one place to another over time

We can create streams to read and write files on node js which will increase performance